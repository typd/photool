#!/usr/bin/env python3

import sys
import os
import PIL.ExifTags
import PIL.Image
from PIL import Image, ImageDraw, ImageFont
import json
import time

def fetch(att, dict):
    if not att in dict:
        return None
    if dict[att] == None or dict[att] == "":
        return None
    return dict[att]

def pick_in_list(index, arr):
    if (not isinstance(arr, list)) and (not isinstance(arr, tuple)):
        return arr
    if len(arr) > 0:
        return arr[index]
    return None

def pick_ratio(k):
    # 5"      : 127mm * 89mm
    # 5" extra: 127mm * 95mm
    # 6"      : 152mm * 102mm
    return {
            "5": 127.0 / 89,
            "5e": 127.0 / 95,
            "6": 152.0 / 102,
            "x": 182.0 / 102
            }[k]

def load_info(img):
    exif = {}
    if img._getexif() == None:
        return None
    for k, v in img._getexif().items():
        if (k in PIL.ExifTags.TAGS) and (not isinstance(v, bytes)):
            kk = PIL.ExifTags.TAGS[k]
            exif[kk] = v
    # print(json.dumps(exif, indent = 4))

    info = {}
    # ref https://www.awaresystems.be/imaging/tiff/tifftags/privateifd/exif.html
    # time
    temp = fetch("DateTimeOriginal", exif)
    ct = time.strptime(temp, "%Y:%m:%d %H:%M:%S")
    # focal, a list
    temp = fetch("FocalLength", exif)
    focal = pick_in_list(0, temp)
    # focal in 35mm
    focal_in35mm = fetch("FocalLengthIn35mmFilm", exif)
    # make
    make = fetch("Make", exif)
    # Model
    model = fetch("Model", exif)
    # ExposureTime
    temp = fetch("ExposureTime", exif)
    exp_time = "{}/{}".format(temp[0], temp[1]) if temp else None
    # f number
    temp = fetch("FNumber", exif)
    temp = float(temp[0]) / temp[1]
    fnumber = "{0:.1f}".format(temp)
    # WhiteBalance
    """
    Indicates the white balance mode set when the image was shot.
    0 = Auto white balance
    1 = Manual white balance
    """
    temp = fetch("WhiteBalance", exif)
    # exposure bias
    """
    The exposure bias.
    The unit is the APEX (Additive System of Photographic Exposure) setting.
    Ordinarily it is given in the range of -99.99 to 99.99.
    """
    temp = fetch("ExposureBiasValue", exif)
    if temp[0] == 0:
        ev = ""
    else:
        temp = float(temp[0]) / temp[1]
        ev = ", {0:.1f}ev".format(temp)
    # exp program
    """
    The class of the program used by the camera to set exposure when the picture is taken.
    0 = Not defined
    1 = Manual
    2 = Normal program
    3 = Aperture priority
    4 = Shutter priority
    5 = Creative program (biased toward depth of field)
    6 = Action program (biased toward fast shutter speed)
    7 = Portrait mode (for closeup photos with the background out of focus)
    8 = Landscape mode (for landscape photos with the background in focus)
    """
    exp_program = fetch("ExposureProgram", exif)
    # ISO
    iso = fetch("ISOSpeedRatings", exif)
    # GainControl ?
    """
    Indicates the degree of overall image gain adjustment.
    0 = None
    1 = Low gain up
    2 = High gain up
    3 = Low gain down
    4 = High gain down
    """
    gain = fetch("GainControl", exif)
    # summary
    info = "{}mm ({}mm in 35mm), f{}, {}s, ISO {}{}, {}, {}".format(focal, focal_in35mm,
            fnumber, exp_time, iso, ev, model, time.strftime("%Y/%m/%d %H:%M", ct))
    return info

def transform(path, exp_ratio):
    print("processing {}".format(path))
    img = PIL.Image.open(path)

    # load info
    info = load_info(img)
    print("    info: {}".format(info))

    # re-size
    w, h = img.size
    ratio = float(w) / h
    if ratio < 1.0:
        exp_ratio = 1.0 / exp_ratio
    d_w = max(int(exp_ratio * h - w), 0)
    d_h = max(int(float(w) / exp_ratio - h), 0)
    print("    size: w{}px, h{}px, ".format(w, h) + "{0:.3f}".format(ratio))
    print("  resize: w{}px, h{}px, ".format(w + d_w, h + d_h) + "{0:.3f}".format(exp_ratio))
    # if too much margin, place image to the center
    # otherwise, place it to one side
    start_h = 0
    if d_h > 100:
        start_h = int(d_h / 2)
    start_w = 0
    if d_w > 100:
        start_w = int(d_w / 2)

    info_on_bottom, info_on_right = False, False
    # need large enough margin 
    if info:
        if d_w > 100:
            info_on_right = True
        if d_h > 100:
            info_on_bottom = True

    # new image
    final = Image.new(mode = 'RGB', size = (w + d_w, h + d_h), color = (0, 0, 0))
    final.paste(img, (start_w, start_h))

    # attach info
    if info_on_bottom or info_on_right:
        fnt = ImageFont.truetype('./fonts/Arial.ttf', 80)
        margin = 20
        if info_on_bottom:
            txt_w, txt_h = (w, d_h - start_h)
        if info_on_right:
            txt_w, txt_h = (h, d_w - start_w)
        txt_img = Image.new('RGB', (txt_w, txt_h), (0, 0, 0))
        txt_d = ImageDraw.Draw(txt_img)
        font_w, font_h = txt_d.textsize(info, font=fnt)
        txt_d.text((txt_w - font_w - margin, margin), info, font=fnt, fill=(200, 200, 200))
        if info_on_bottom:
            final.paste(txt_img, (start_w, start_h + h))
        if info_on_right:
            txt_img = txt_img.rotate(90, expand=1)
            final.paste(txt_img, (start_w + w, start_h))

    return final

def main():
    path = "tests/d1.jpg"
    size = "5e"
    ratio = pick_ratio(size)
    img = transform(path, ratio)
    img.show()
    img.save("out.jpg", "JPEG", quality=100, optimize=True, progressive=True)

if __name__ == "__main__":
    main()
